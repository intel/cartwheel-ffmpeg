From c941590430175895c378c7f2bcd95218ad2b607d Mon Sep 17 00:00:00 2001
From: Wenbinc-Bin <wenbin.chen@intel.com>
Date: Thu, 14 Jan 2021 15:55:47 +0800
Subject: [PATCH 58/94] libavcodec/qsvenc.c: add ROI support to qsv encoder

Use the mfxEncoderCtrl parameter to enable ROI. Get side data "AVRegionOfInterest"
from filter "addroi" and use it to configure "mfxExtEncoderROI" which is
the MediaSDK's ROI configuration.
It is the first time to use encoderCtrl feature in ffmpeg-qsv,
so add allocate and free process as well.

Sigend-off-by: Wenbin Chen <wenbin.chen@intel.com>
---
 libavcodec/qsv_internal.h |  4 +++
 libavcodec/qsvenc.c       | 75 +++++++++++++++++++++++++++++++++++++++
 2 files changed, 79 insertions(+)

diff --git a/libavcodec/qsv_internal.h b/libavcodec/qsv_internal.h
index dd64e58941..6922af4213 100644
--- a/libavcodec/qsv_internal.h
+++ b/libavcodec/qsv_internal.h
@@ -51,6 +51,9 @@
 #define ASYNC_DEPTH_DEFAULT 4       // internal parallelism
 
 #define QSV_MAX_ENC_PAYLOAD 2       // # of mfxEncodeCtrl payloads supported
+#define QSV_MAX_ENC_EXTPARAM 2
+
+#define QSV_MAX_ROI_NUM 256
 
 #define QSV_PAYLOAD_SIZE 1024
 
@@ -79,6 +82,7 @@ typedef struct QSVFrame {
     mfxExtBuffer *ext_param;
 
     mfxPayload *payloads[QSV_MAX_ENC_PAYLOAD]; ///< used for enc_ctrl.Payload
+    mfxExtBuffer *extparam[QSV_MAX_ENC_EXTPARAM]; ///< used for enc_ctrl.ExtParam
 
     int queued;
     int used;
diff --git a/libavcodec/qsvenc.c b/libavcodec/qsvenc.c
index 764c7574a1..681ff8e7d1 100644
--- a/libavcodec/qsvenc.c
+++ b/libavcodec/qsvenc.c
@@ -1314,15 +1314,28 @@ static void free_encoder_ctrl_payloads(mfxEncodeCtrl* enc_ctrl)
     }
 }
 
+static void free_encoder_ctrl_extparam(mfxEncodeCtrl* enc_ctrl)
+{
+    if (enc_ctrl) {
+        for (int i = 0; i < enc_ctrl->NumExtParam && i < QSV_MAX_ENC_EXTPARAM; i++) {
+            if (enc_ctrl->ExtParam[i])
+                av_freep(&(enc_ctrl->ExtParam[i]));
+        }
+        enc_ctrl->NumExtParam = 0;
+    }
+}
+
 static void clear_unused_frames(QSVEncContext *q)
 {
     QSVFrame *cur = q->work_frames;
     while (cur) {
         if (cur->used && !cur->surface.Data.Locked) {
+            free_encoder_ctrl_extparam(&cur->enc_ctrl);
             free_encoder_ctrl_payloads(&cur->enc_ctrl);
             //do not reuse enc_ctrl from previous frame
             memset(&cur->enc_ctrl, 0, sizeof(cur->enc_ctrl));
             cur->enc_ctrl.Payload = cur->payloads;
+            cur->enc_ctrl.ExtParam = cur->extparam;
             if (cur->frame->format == AV_PIX_FMT_QSV) {
                 av_frame_unref(cur->frame);
             }
@@ -1360,6 +1373,7 @@ static int get_free_frame(QSVEncContext *q, QSVFrame **f)
         return AVERROR(ENOMEM);
     }
     frame->enc_ctrl.Payload = frame->payloads;
+    frame->enc_ctrl.ExtParam = frame->extparam;
     *last = frame;
 
     *f = frame;
@@ -1463,6 +1477,7 @@ static int encode_frame(AVCodecContext *avctx, QSVEncContext *q,
                         const AVFrame *frame)
 {
     AVPacket new_pkt = { 0 };
+    AVFrameSideData *sd;
     mfxBitstream *bs = NULL;
 #if QSV_VERSION_ATLEAST(1, 26)
     mfxExtAVCEncodedFrameInfo *enc_info = NULL;
@@ -1473,6 +1488,7 @@ static int encode_frame(AVCodecContext *avctx, QSVEncContext *q,
     mfxSyncPoint *sync     = NULL;
     QSVFrame *qsv_frame = NULL;
     mfxEncodeCtrl* enc_ctrl = NULL;
+    mfxExtEncoderROI *enc_roi = NULL;
     int ret;
 
     if (frame) {
@@ -1505,6 +1521,8 @@ static int encode_frame(AVCodecContext *avctx, QSVEncContext *q,
     bs->Data      = new_pkt.data;
     bs->MaxLength = new_pkt.size;
 
+    enc_info = NULL;
+    enc_buf = NULL;
 #if QSV_VERSION_ATLEAST(1, 26)
     if (avctx->codec_id == AV_CODEC_ID_H264) {
         enc_info = av_mallocz(sizeof(*enc_info));
@@ -1527,6 +1545,62 @@ static int encode_frame(AVCodecContext *avctx, QSVEncContext *q,
         q->set_encode_ctrl_cb(avctx, frame, &qsv_frame->enc_ctrl);
     }
 
+#if QSV_VERSION_ATLEAST(1, 22)
+    sd = NULL;
+    if (frame) {
+        sd = av_frame_get_side_data(frame,
+                                    AV_FRAME_DATA_REGIONS_OF_INTEREST);
+    }
+    if (sd) {
+        AVRegionOfInterest *roi;
+        uint32_t roi_size;
+        int nb_roi, i;
+
+        enc_roi = (mfxExtEncoderROI *)av_mallocz(sizeof(*enc_roi));
+        if (!enc_roi) {
+            av_packet_unref(&new_pkt);
+            if (bs)
+                av_freep(bs);
+            if (enc_info)
+                av_freep(&enc_info);
+            if (enc_buf)
+                av_freep(&enc_buf);
+            return AVERROR(ENOMEM);
+        }
+        roi = (AVRegionOfInterest *)sd->data;
+        roi_size = roi->self_size;
+        av_assert0(roi_size && sd->size % roi_size == 0);
+        nb_roi = sd->size / roi_size;
+        if (nb_roi > QSV_MAX_ROI_NUM) {
+            av_log(avctx, AV_LOG_WARNING, "More ROIs set than "
+                    "supported by driver (%d > %d).\n",
+                    nb_roi, QSV_MAX_ROI_NUM);
+            nb_roi = QSV_MAX_ROI_NUM;
+        }
+        enc_roi->Header.BufferId = MFX_EXTBUFF_ENCODER_ROI;
+        enc_roi->Header.BufferSz = sizeof(*enc_roi);
+        enc_roi->NumROI  = nb_roi;
+        enc_roi->ROIMode = MFX_ROI_MODE_QP_DELTA;
+        // For overlapping regions, the first in the array takes priority.
+        for (i = 0; i < nb_roi; i++) {
+            roi = (AVRegionOfInterest*)(sd->data + roi_size * i);
+            av_assert0(roi->qoffset.den != 0);
+
+            enc_roi->ROI[i].Top = roi->top & 0xfffffff0;
+            enc_roi->ROI[i].Bottom = roi->bottom & 0xfffffff0;
+            enc_roi->ROI[i].Left = (roi->left & 0xfffffff0) + 0x10;
+            enc_roi->ROI[i].Right = (roi->right & 0xfffffff0) + 0x10;
+            enc_roi->ROI[i].DeltaQP =
+                        roi->qoffset.num * 51 / roi->qoffset.den;
+            av_log(avctx, AV_LOG_DEBUG, "ROI: (%d,%d)-(%d,%d) -> %+d.\n",
+                   roi->top, roi->left, roi->bottom, roi->right,
+                   enc_roi->ROI[i].DeltaQP);
+        }
+        enc_ctrl->ExtParam[enc_ctrl->NumExtParam] = (mfxExtBuffer *)enc_roi;
+        enc_ctrl->NumExtParam += 1;
+    }
+#endif
+
     sync = av_mallocz(sizeof(*sync));
     if (!sync)
         goto nomem;
@@ -1661,6 +1735,7 @@ int ff_qsv_enc_close(AVCodecContext *avctx, QSVEncContext *q)
     while (cur) {
         q->work_frames = cur->next;
         av_frame_free(&cur->frame);
+        free_encoder_ctrl_extparam(&cur->enc_ctrl);
         free_encoder_ctrl_payloads(&cur->enc_ctrl);
         av_freep(&cur);
         cur = q->work_frames;
-- 
2.25.1

