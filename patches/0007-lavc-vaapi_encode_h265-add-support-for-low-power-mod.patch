From f625a118dafbd0d5a7bbd3aaa5ec63a5d8143a12 Mon Sep 17 00:00:00 2001
From: Linjie Fu <linjie.fu@intel.com>
Date: Tue, 3 Dec 2019 16:07:48 +0800
Subject: [PATCH 07/68] lavc/vaapi_encode_h265: add support for low power mode
 for HEVC encode

Enable hevc_vaapi vdenc:
    - media-driver require CTU size must be set as 64x64 at low power mode
    - cu_qp_delta_enabled_flag should be enabled for low power mode
    - diff_cu_qp_delta_depth == log2_diff_max_min_luma_coding_block_size
    - low delay B to replace P frame
    - same ref_pic_list0/ref_pic_list1

Signed-off-by: Linjie Fu <linjie.fu@intel.com>
---
 libavcodec/vaapi_encode_h265.c | 22 +++++++++++++++-------
 1 file changed, 15 insertions(+), 7 deletions(-)

diff --git a/libavcodec/vaapi_encode_h265.c b/libavcodec/vaapi_encode_h265.c
index 456307d570..399a10760a 100644
--- a/libavcodec/vaapi_encode_h265.c
+++ b/libavcodec/vaapi_encode_h265.c
@@ -433,9 +433,12 @@ static int vaapi_encode_h265_init_sequence_params(AVCodecContext *avctx)
     // These values come from the capabilities of the first encoder
     // implementation in the i965 driver on Intel Skylake.  They may
     // fail badly with other platforms or drivers.
-    // CTB size from 8x8 to 32x32.
+    // CTB size from 8x8 to 32x32. (64x64 when using low power mode for hw limitation)
     sps->log2_min_luma_coding_block_size_minus3   = 0;
-    sps->log2_diff_max_min_luma_coding_block_size = 2;
+    if (ctx->low_power)
+        sps->log2_diff_max_min_luma_coding_block_size = 3;
+    else
+        sps->log2_diff_max_min_luma_coding_block_size = 2;
     // Transform size from 4x4 to 32x32.
     sps->log2_min_luma_transform_block_size_minus2   = 0;
     sps->log2_diff_max_min_luma_transform_block_size = 3;
@@ -575,8 +578,10 @@ static int vaapi_encode_h265_init_sequence_params(AVCodecContext *avctx)
 
     pps->init_qp_minus26 = priv->fixed_qp_idr - 26;
 
-    pps->cu_qp_delta_enabled_flag = (ctx->va_rc_mode != VA_RC_CQP);
-    pps->diff_cu_qp_delta_depth   = 0;
+    // driver requires enablement of cu_qp_delta_enabled_flag for low power mode encoding
+    pps->cu_qp_delta_enabled_flag = (ctx->va_rc_mode != VA_RC_CQP | ctx->low_power);
+    pps->diff_cu_qp_delta_depth   = pps->cu_qp_delta_enabled_flag && ctx->low_power ?
+                                        sps->log2_diff_max_min_luma_coding_block_size : 0;
 
 // update pps setting according to queried result
 #if VA_CHECK_VERSION(1, 13, 0)
@@ -976,7 +981,8 @@ static int vaapi_encode_h265_init_slice_params(AVCodecContext *avctx,
 
     sh->slice_type = hpic->slice_type;
 
-    if (sh->slice_type == HEVC_SLICE_P && ctx->p_to_gpb)
+    // driver requires low delay B frame in low power mode
+    if (sh->slice_type == HEVC_SLICE_P && (ctx->p_to_gpb || ctx->low_power))
         sh->slice_type = HEVC_SLICE_B;
 
     sh->slice_pic_order_cnt_lsb = hpic->pic_order_cnt &
@@ -1150,7 +1156,9 @@ static int vaapi_encode_h265_init_slice_params(AVCodecContext *avctx,
         vslice->ref_pic_list1[0] = vpic->reference_frames[1];
     }
 
-    if (pic->type == PICTURE_TYPE_P && ctx->p_to_gpb) {
+    // Driver requires low delay B frame and matched ref_pic_list0/1[]
+    // for low power mode
+    if (pic->type == PICTURE_TYPE_P && (ctx->p_to_gpb || ctx->low_power)) {
         vslice->slice_type = HEVC_SLICE_B;
         for (i = 0; i < FF_ARRAY_ELEMS(vslice->ref_pic_list0); i++) {
             vslice->ref_pic_list1[i].picture_id = vslice->ref_pic_list0[i].picture_id;
@@ -1208,7 +1216,7 @@ static av_cold int vaapi_encode_h265_get_encoder_caps(AVCodecContext *avctx)
 #endif
 
     if (!priv->ctu_size) {
-        priv->ctu_size     = 32;
+        priv->ctu_size     =  ctx->low_power ? 64 : 32;
         priv->min_cb_size  = 16;
     }
     av_log(avctx, AV_LOG_VERBOSE, "Using CTU size %dx%d, "
-- 
2.32.0

