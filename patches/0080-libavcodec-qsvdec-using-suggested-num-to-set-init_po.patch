From a18db98a61767204e709119dff5ebc550f4d4b51 Mon Sep 17 00:00:00 2001
From: Wenbinc-Bin <wenbin.chen@intel.com>
Date: Tue, 26 Jan 2021 09:55:59 +0800
Subject: [PATCH 63/70] libavcodec/qsvdec: using suggested num to set
 init_pool_size

The init_pool_size is set to be 64 and it is too many.
Use IOSurfQuery to get NumFrameSuggest which is the suggested
number of frame that needed to be allocated when initializing the decoder.
Considering that the hevc_qsv encoder uses the  most frame buffer,
async is 4 (default) and max_b_frames is 8 (default) and decoder
may followed by VPP, use NumFrameSuggest + 16 to set init_pool_size.

Sigend-off-by Wenbin Chen <wenbin.chen@intel.com>
Signed-off-by Guangxin Xu <guangxin.xu@intel.com>
---
 libavcodec/qsvdec.c | 14 ++++++++++++--
 1 file changed, 12 insertions(+), 2 deletions(-)

diff --git a/libavcodec/qsvdec.c b/libavcodec/qsvdec.c
index b3ddd7ffdc..98841c0268 100644
--- a/libavcodec/qsvdec.c
+++ b/libavcodec/qsvdec.c
@@ -95,7 +95,7 @@ typedef struct QSVContext {
     uint32_t fourcc;
     mfxFrameInfo frame_info;
     AVBufferPool *pool;
-
+    int suggest_pool_size;
     int initialized;
 
     // options set by the caller
@@ -297,7 +297,7 @@ static int qsv_decode_preinit(AVCodecContext *avctx, QSVContext *q, enum AVPixel
         hwframes_ctx->height            = FFALIGN(avctx->coded_height, 32);
         hwframes_ctx->format            = AV_PIX_FMT_QSV;
         hwframes_ctx->sw_format         = avctx->sw_pix_fmt;
-        hwframes_ctx->initial_pool_size = 64 + avctx->extra_hw_frames;
+        hwframes_ctx->initial_pool_size = q->suggest_pool_size + 16 + avctx->extra_hw_frames;
         frames_hwctx->frame_type        = MFX_MEMTYPE_VIDEO_MEMORY_DECODER_TARGET;
 
         ret = av_hwframe_ctx_init(avctx->hw_frames_ctx);
@@ -967,6 +967,9 @@ static int qsv_process_data(AVCodecContext *avctx, QSVContext *q,
     }
 
     if (q->reinit_flag || !q->session || !q->initialized) {
+        mfxFrameAllocRequest request;
+        memset(&request, 0, sizeof(request));
+
         q->reinit_flag = 0;
         ret = qsv_decode_header(avctx, q, pkt, pix_fmt, &param);
         if (ret < 0) {
@@ -976,12 +979,19 @@ static int qsv_process_data(AVCodecContext *avctx, QSVContext *q,
                 av_log(avctx, AV_LOG_ERROR, "Error decoding header\n");
             goto reinit_fail;
         }
+        param.IOPattern = q->iopattern;
 
         q->orig_pix_fmt = avctx->pix_fmt = pix_fmt = ff_qsv_map_fourcc(param.mfx.FrameInfo.FourCC);
 
         avctx->coded_width  = param.mfx.FrameInfo.Width;
         avctx->coded_height = param.mfx.FrameInfo.Height;
 
+        ret = MFXVideoDECODE_QueryIOSurf(q->session, &param, &request);
+        if (ret < 0)
+            return ff_qsv_print_error(avctx, ret, "Error querying IO surface");
+
+        q->suggest_pool_size = request.NumFrameSuggested;
+
         ret = qsv_decode_preinit(avctx, q, pix_fmt, &param);
         if (ret < 0)
             goto reinit_fail;
-- 
2.17.1

